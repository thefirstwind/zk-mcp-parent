<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SSE æµå¼è°ƒç”¨æµ‹è¯•å®¢æˆ·ç«¯</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            margin: 0;
            padding: 20px;
            background-color: #f5f5f5;
        }
        .container {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
        }
        .content {
            padding: 20px;
        }
        .test-section {
            margin-bottom: 30px;
            border: 1px solid #e0e0e0;
            border-radius: 8px;
            padding: 20px;
        }
        .test-section h3 {
            margin-top: 0;
            color: #333;
            border-bottom: 2px solid #667eea;
            padding-bottom: 10px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
            font-weight: bold;
            color: #555;
        }
        .form-group input, .form-group textarea, .form-group select {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
        }
        .form-group textarea {
            height: 100px;
            resize: vertical;
        }
        .button-group {
            display: flex;
            gap: 10px;
            margin-top: 15px;
        }
        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            font-weight: bold;
            transition: all 0.3s;
        }
        .btn-primary {
            background: #667eea;
            color: white;
        }
        .btn-primary:hover {
            background: #5a6fd8;
        }
        .btn-danger {
            background: #dc3545;
            color: white;
        }
        .btn-danger:hover {
            background: #c82333;
        }
        .btn-success {
            background: #28a745;
            color: white;
        }
        .btn-success:hover {
            background: #218838;
        }
        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }
        .log-container {
            background: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px;
            height: 300px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
        }
        .log-entry {
            margin-bottom: 5px;
            padding: 5px;
            border-radius: 3px;
        }
        .log-info {
            background: #d1ecf1;
            color: #0c5460;
        }
        .log-success {
            background: #d4edda;
            color: #155724;
        }
        .log-error {
            background: #f8d7da;
            color: #721c24;
        }
        .log-data {
            background: #fff3cd;
            color: #856404;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-connected {
            background: #28a745;
        }
        .status-disconnected {
            background: #dc3545;
        }
        .status-connecting {
            background: #ffc107;
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.5; }
            100% { opacity: 1; }
        }
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 20px;
        }
        .stat-card {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #667eea;
        }
        .stat-label {
            font-size: 12px;
            color: #6c757d;
            margin-top: 5px;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸŒŠ SSE æµå¼è°ƒç”¨æµ‹è¯•å®¢æˆ·ç«¯</h1>
            <p>æµ‹è¯• ZK MCP Parent é¡¹ç›®çš„ Server-Sent Events æµå¼ä¼ è¾“åŠŸèƒ½</p>
        </div>
        
        <div class="content">
            <!-- åŸºç¡€ SSE æµ‹è¯• -->
            <div class="test-section">
                <h3>ğŸ“¡ åŸºç¡€ SSE æµå¼è°ƒç”¨æµ‹è¯•</h3>
                <div class="form-group">
                    <label for="basicToolName">å·¥å…·åç§°:</label>
                    <select id="basicToolName">
                        <option value="com.zkinfo.demo.service.UserService.getUserById">è·å–ç”¨æˆ·ä¿¡æ¯</option>
                        <option value="com.zkinfo.demo.service.OrderService.getOrderById">è·å–è®¢å•ä¿¡æ¯</option>
                        <option value="com.zkinfo.demo.service.ProductService.getProductById">è·å–äº§å“ä¿¡æ¯</option>
                        <option value="com.zkinfo.demo.service.UserService.getAllUsers">è·å–æ‰€æœ‰ç”¨æˆ·</option>
                    </select>
                </div>
                <div class="form-group">
                    <label for="basicArguments">å‚æ•° (JSONæ ¼å¼):</label>
                    <textarea id="basicArguments" placeholder='{"args": [1]}'></textarea>
                </div>
                <div class="button-group">
                    <button id="basicStartBtn" class="btn btn-primary" onclick="startBasicSseTest()">å¼€å§‹æµå¼è°ƒç”¨</button>
                    <button id="basicStopBtn" class="btn btn-danger" onclick="stopBasicSseTest()" disabled>åœæ­¢è°ƒç”¨</button>
                    <button class="btn btn-success" onclick="clearBasicLog()">æ¸…ç©ºæ—¥å¿—</button>
                </div>
                <div class="form-group">
                    <label>è¿æ¥çŠ¶æ€: <span id="basicStatus" class="status-indicator status-disconnected"></span><span id="basicStatusText">æœªè¿æ¥</span></label>
                </div>
                <div class="log-container" id="basicLog"></div>
            </div>

            <!-- å¹¶å‘ SSE æµ‹è¯• -->
            <div class="test-section">
                <h3>ğŸš€ å¹¶å‘ SSE æµå¼è°ƒç”¨æµ‹è¯•</h3>
                <div class="form-group">
                    <label for="concurrentCount">å¹¶å‘æ•°é‡:</label>
                    <input type="number" id="concurrentCount" value="3" min="1" max="10">
                </div>
                <div class="form-group">
                    <label for="concurrentDelay">è°ƒç”¨é—´éš” (æ¯«ç§’):</label>
                    <input type="number" id="concurrentDelay" value="500" min="100" max="5000">
                </div>
                <div class="button-group">
                    <button id="concurrentStartBtn" class="btn btn-primary" onclick="startConcurrentSseTest()">å¼€å§‹å¹¶å‘æµ‹è¯•</button>
                    <button id="concurrentStopBtn" class="btn btn-danger" onclick="stopConcurrentSseTest()" disabled>åœæ­¢æ‰€æœ‰</button>
                    <button class="btn btn-success" onclick="clearConcurrentLog()">æ¸…ç©ºæ—¥å¿—</button>
                </div>
                <div class="log-container" id="concurrentLog"></div>
            </div>

            <!-- é•¿æ—¶é—´è¿è¡Œæµ‹è¯• -->
            <div class="test-section">
                <h3>â±ï¸ é•¿æ—¶é—´è¿è¡Œ SSE æµ‹è¯•</h3>
                <div class="form-group">
                    <label for="longRunningDuration">è¿è¡Œæ—¶é•¿ (ç§’):</label>
                    <input type="number" id="longRunningDuration" value="30" min="10" max="300">
                </div>
                <div class="form-group">
                    <label for="longRunningInterval">æ•°æ®æ¨é€é—´éš” (æ¯«ç§’):</label>
                    <input type="number" id="longRunningInterval" value="1000" min="100" max="10000">
                </div>
                <div class="button-group">
                    <button id="longRunningStartBtn" class="btn btn-primary" onclick="startLongRunningSseTest()">å¼€å§‹é•¿æ—¶é—´æµ‹è¯•</button>
                    <button id="longRunningStopBtn" class="btn btn-danger" onclick="stopLongRunningSseTest()" disabled>åœæ­¢æµ‹è¯•</button>
                    <button class="btn btn-success" onclick="clearLongRunningLog()">æ¸…ç©ºæ—¥å¿—</button>
                </div>
                <div class="log-container" id="longRunningLog"></div>
            </div>

            <!-- é”™è¯¯å¤„ç†æµ‹è¯• -->
            <div class="test-section">
                <h3>âŒ é”™è¯¯å¤„ç†æµ‹è¯•</h3>
                <div class="form-group">
                    <label for="errorTestType">é”™è¯¯ç±»å‹:</label>
                    <select id="errorTestType">
                        <option value="invalid_stream_id">æ— æ•ˆæµID</option>
                        <option value="invalid_tool_name">æ— æ•ˆå·¥å…·åç§°</option>
                        <option value="invalid_arguments">æ— æ•ˆå‚æ•°</option>
                        <option value="network_error">ç½‘ç»œé”™è¯¯æ¨¡æ‹Ÿ</option>
                    </select>
                </div>
                <div class="button-group">
                    <button id="errorTestBtn" class="btn btn-primary" onclick="startErrorTest()">å¼€å§‹é”™è¯¯æµ‹è¯•</button>
                    <button class="btn btn-success" onclick="clearErrorLog()">æ¸…ç©ºæ—¥å¿—</button>
                </div>
                <div class="log-container" id="errorLog"></div>
            </div>

            <!-- ç»Ÿè®¡ä¿¡æ¯ -->
            <div class="test-section">
                <h3>ğŸ“Š æµ‹è¯•ç»Ÿè®¡</h3>
                <div class="stats">
                    <div class="stat-card">
                        <div class="stat-value" id="totalConnections">0</div>
                        <div class="stat-label">æ€»è¿æ¥æ•°</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="activeConnections">0</div>
                        <div class="stat-label">æ´»è·ƒè¿æ¥</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="totalMessages">0</div>
                        <div class="stat-label">æ¥æ”¶æ¶ˆæ¯æ•°</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="errorCount">0</div>
                        <div class="stat-label">é”™è¯¯æ¬¡æ•°</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="avgLatency">0ms</div>
                        <div class="stat-label">å¹³å‡å»¶è¿Ÿ</div>
                    </div>
                    <div class="stat-card">
                        <div class="stat-value" id="uptime">0s</div>
                        <div class="stat-label">è¿è¡Œæ—¶é—´</div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // å…¨å±€å˜é‡
        let basicEventSource = null;
        let concurrentEventSources = [];
        let longRunningEventSource = null;
        let stats = {
            totalConnections: 0,
            activeConnections: 0,
            totalMessages: 0,
            errorCount: 0,
            latencies: [],
            startTime: null
        };

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        function updateStats() {
            document.getElementById('totalConnections').textContent = stats.totalConnections;
            document.getElementById('activeConnections').textContent = stats.activeConnections;
            document.getElementById('totalMessages').textContent = stats.totalMessages;
            document.getElementById('errorCount').textContent = stats.errorCount;
            
            const avgLatency = stats.latencies.length > 0 
                ? Math.round(stats.latencies.reduce((a, b) => a + b, 0) / stats.latencies.length)
                : 0;
            document.getElementById('avgLatency').textContent = avgLatency + 'ms';
            
            const uptime = stats.startTime 
                ? Math.round((Date.now() - stats.startTime) / 1000)
                : 0;
            document.getElementById('uptime').textContent = uptime + 's';
        }

        // æ·»åŠ æ—¥å¿—
        function addLog(containerId, type, message, data = null) {
            const container = document.getElementById(containerId);
            const entry = document.createElement('div');
            entry.className = `log-entry log-${type}`;
            
            const timestamp = new Date().toLocaleTimeString();
            let content = `[${timestamp}] ${message}`;
            
            if (data) {
                content += '\n' + JSON.stringify(data, null, 2);
            }
            
            entry.textContent = content;
            container.appendChild(entry);
            container.scrollTop = container.scrollHeight;
        }

        // åŸºç¡€ SSE æµ‹è¯•
        async function startBasicSseTest() {
            const toolName = document.getElementById('basicToolName').value;
            const argumentsText = document.getElementById('basicArguments').value;
            
            try {
                const arguments_ = argumentsText ? JSON.parse(argumentsText) : {};
                
                // æ›´æ–°çŠ¶æ€
                updateConnectionStatus('basic', 'connecting', 'è¿æ¥ä¸­...');
                document.getElementById('basicStartBtn').disabled = true;
                
                // åˆ›å»ºæµå¼è°ƒç”¨
                const response = await fetch('/mcp/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 'basic-test-' + Date.now(),
                        method: 'tools/call',
                        params: {
                            name: toolName,
                            arguments: arguments_,
                            stream: true
                        }
                    })
                });
                
                const result = await response.json();
                addLog('basicLog', 'info', 'åˆ›å»ºæµå¼è°ƒç”¨', result);
                
                if (result.streamId) {
                    // å¼€å§‹ SSE ç›‘å¬
                    basicEventSource = new EventSource(`/mcp/stream/${result.streamId}`);
                    stats.totalConnections++;
                    stats.activeConnections++;
                    
                    const startTime = Date.now();
                    
                    basicEventSource.onopen = function() {
                        updateConnectionStatus('basic', 'connected', 'å·²è¿æ¥');
                        addLog('basicLog', 'success', 'SSE è¿æ¥å·²å»ºç«‹');
                        document.getElementById('basicStopBtn').disabled = false;
                    };
                    
                    basicEventSource.onmessage = function(event) {
                        const latency = Date.now() - startTime;
                        stats.latencies.push(latency);
                        stats.totalMessages++;
                        
                        try {
                            const data = JSON.parse(event.data);
                            addLog('basicLog', 'data', 'æ¥æ”¶åˆ°æ•°æ®', data);
                        } catch (e) {
                            addLog('basicLog', 'data', 'æ¥æ”¶åˆ°æ•°æ®: ' + event.data);
                        }
                        updateStats();
                    };
                    
                    basicEventSource.onerror = function(event) {
                        addLog('basicLog', 'error', 'SSE è¿æ¥é”™è¯¯');
                        stats.errorCount++;
                        updateConnectionStatus('basic', 'disconnected', 'è¿æ¥é”™è¯¯');
                        stopBasicSseTest();
                    };
                    
                } else {
                    addLog('basicLog', 'error', 'åˆ›å»ºæµå¼è°ƒç”¨å¤±è´¥', result);
                    updateConnectionStatus('basic', 'disconnected', 'åˆ›å»ºå¤±è´¥');
                    document.getElementById('basicStartBtn').disabled = false;
                }
                
            } catch (error) {
                addLog('basicLog', 'error', 'è¯·æ±‚å¤±è´¥: ' + error.message);
                updateConnectionStatus('basic', 'disconnected', 'è¯·æ±‚å¤±è´¥');
                document.getElementById('basicStartBtn').disabled = false;
                stats.errorCount++;
            }
            
            updateStats();
        }

        function stopBasicSseTest() {
            if (basicEventSource) {
                basicEventSource.close();
                basicEventSource = null;
                stats.activeConnections--;
            }
            
            updateConnectionStatus('basic', 'disconnected', 'å·²æ–­å¼€');
            document.getElementById('basicStartBtn').disabled = false;
            document.getElementById('basicStopBtn').disabled = true;
            addLog('basicLog', 'info', 'SSE è¿æ¥å·²å…³é—­');
            updateStats();
        }

        // å¹¶å‘ SSE æµ‹è¯•
        async function startConcurrentSseTest() {
            const count = parseInt(document.getElementById('concurrentCount').value);
            const delay = parseInt(document.getElementById('concurrentDelay').value);
            
            document.getElementById('concurrentStartBtn').disabled = true;
            document.getElementById('concurrentStopBtn').disabled = false;
            
            addLog('concurrentLog', 'info', `å¼€å§‹ ${count} ä¸ªå¹¶å‘ SSE è¿æ¥æµ‹è¯•`);
            
            for (let i = 0; i < count; i++) {
                setTimeout(async () => {
                    try {
                        const response = await fetch('/mcp/stream', {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                jsonrpc: '2.0',
                                id: `concurrent-${i}-${Date.now()}`,
                                method: 'tools/call',
                                params: {
                                    name: 'com.zkinfo.demo.service.UserService.getUserById',
                                    arguments: { args: [i + 1] },
                                    stream: true
                                }
                            })
                        });
                        
                        const result = await response.json();
                        
                        if (result.streamId) {
                            const eventSource = new EventSource(`/mcp/stream/${result.streamId}`);
                            concurrentEventSources.push(eventSource);
                            stats.totalConnections++;
                            stats.activeConnections++;
                            
                            eventSource.onmessage = function(event) {
                                stats.totalMessages++;
                                addLog('concurrentLog', 'data', `è¿æ¥ ${i + 1} æ¥æ”¶æ•°æ®`, JSON.parse(event.data));
                                updateStats();
                            };
                            
                            eventSource.onerror = function() {
                                addLog('concurrentLog', 'error', `è¿æ¥ ${i + 1} å‘ç”Ÿé”™è¯¯`);
                                stats.errorCount++;
                                stats.activeConnections--;
                                updateStats();
                            };
                            
                            addLog('concurrentLog', 'success', `è¿æ¥ ${i + 1} å·²å»ºç«‹`);
                        }
                        
                    } catch (error) {
                        addLog('concurrentLog', 'error', `è¿æ¥ ${i + 1} åˆ›å»ºå¤±è´¥: ${error.message}`);
                        stats.errorCount++;
                    }
                    updateStats();
                }, i * delay);
            }
        }

        function stopConcurrentSseTest() {
            concurrentEventSources.forEach((eventSource, index) => {
                if (eventSource) {
                    eventSource.close();
                    addLog('concurrentLog', 'info', `è¿æ¥ ${index + 1} å·²å…³é—­`);
                }
            });
            
            stats.activeConnections -= concurrentEventSources.length;
            concurrentEventSources = [];
            
            document.getElementById('concurrentStartBtn').disabled = false;
            document.getElementById('concurrentStopBtn').disabled = true;
            addLog('concurrentLog', 'info', 'æ‰€æœ‰å¹¶å‘è¿æ¥å·²å…³é—­');
            updateStats();
        }

        // é•¿æ—¶é—´è¿è¡Œæµ‹è¯•
        async function startLongRunningSseTest() {
            const duration = parseInt(document.getElementById('longRunningDuration').value);
            
            document.getElementById('longRunningStartBtn').disabled = true;
            document.getElementById('longRunningStopBtn').disabled = false;
            
            addLog('longRunningLog', 'info', `å¼€å§‹ ${duration} ç§’é•¿æ—¶é—´è¿è¡Œæµ‹è¯•`);
            
            try {
                const response = await fetch('/mcp/stream', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 'long-running-' + Date.now(),
                        method: 'tools/call',
                        params: {
                            name: 'com.zkinfo.demo.service.UserService.getAllUsers',
                            arguments: {},
                            stream: true
                        }
                    })
                });
                
                const result = await response.json();
                
                if (result.streamId) {
                    longRunningEventSource = new EventSource(`/mcp/stream/${result.streamId}`);
                    stats.totalConnections++;
                    stats.activeConnections++;
                    
                    const startTime = Date.now();
                    
                    longRunningEventSource.onmessage = function(event) {
                        const elapsed = Math.round((Date.now() - startTime) / 1000);
                        stats.totalMessages++;
                        addLog('longRunningLog', 'data', `[${elapsed}s] æ¥æ”¶æ•°æ®`, JSON.parse(event.data));
                        updateStats();
                    };
                    
                    longRunningEventSource.onerror = function() {
                        addLog('longRunningLog', 'error', 'é•¿æ—¶é—´è¿æ¥å‘ç”Ÿé”™è¯¯');
                        stats.errorCount++;
                        stopLongRunningSseTest();
                    };
                    
                    // è‡ªåŠ¨åœæ­¢
                    setTimeout(() => {
                        if (longRunningEventSource) {
                            stopLongRunningSseTest();
                            addLog('longRunningLog', 'info', 'é•¿æ—¶é—´æµ‹è¯•è‡ªåŠ¨ç»“æŸ');
                        }
                    }, duration * 1000);
                }
                
            } catch (error) {
                addLog('longRunningLog', 'error', 'é•¿æ—¶é—´æµ‹è¯•å¯åŠ¨å¤±è´¥: ' + error.message);
                document.getElementById('longRunningStartBtn').disabled = false;
                document.getElementById('longRunningStopBtn').disabled = true;
                stats.errorCount++;
            }
            
            updateStats();
        }

        function stopLongRunningSseTest() {
            if (longRunningEventSource) {
                longRunningEventSource.close();
                longRunningEventSource = null;
                stats.activeConnections--;
            }
            
            document.getElementById('longRunningStartBtn').disabled = false;
            document.getElementById('longRunningStopBtn').disabled = true;
            addLog('longRunningLog', 'info', 'é•¿æ—¶é—´æµ‹è¯•å·²åœæ­¢');
            updateStats();
        }

        // é”™è¯¯å¤„ç†æµ‹è¯•
        async function startErrorTest() {
            const errorType = document.getElementById('errorTestType').value;
            
            addLog('errorLog', 'info', `å¼€å§‹é”™è¯¯æµ‹è¯•: ${errorType}`);
            
            let testUrl = '';
            let testBody = null;
            
            switch (errorType) {
                case 'invalid_stream_id':
                    testUrl = '/mcp/stream/invalid_stream_id_12345';
                    break;
                case 'invalid_tool_name':
                    testUrl = '/mcp/stream';
                    testBody = {
                        jsonrpc: '2.0',
                        id: 'error-test',
                        method: 'tools/call',
                        params: {
                            name: 'com.invalid.Service.invalidMethod',
                            arguments: {},
                            stream: true
                        }
                    };
                    break;
                case 'invalid_arguments':
                    testUrl = '/mcp/stream';
                    testBody = {
                        jsonrpc: '2.0',
                        id: 'error-test',
                        method: 'tools/call',
                        params: {
                            name: 'com.zkinfo.demo.service.UserService.getUserById',
                            arguments: { invalid: 'arguments' },
                            stream: true
                        }
                    };
                    break;
                case 'network_error':
                    testUrl = '/mcp/stream/network_error_test';
                    break;
            }
            
            try {
                if (testBody) {
                    // å…ˆåˆ›å»ºæµï¼Œå†è¿æ¥
                    const response = await fetch(testUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(testBody)
                    });
                    
                    const result = await response.json();
                    addLog('errorLog', 'info', 'åˆ›å»ºæµå“åº”', result);
                    
                    if (result.streamId) {
                        testUrl = `/mcp/stream/${result.streamId}`;
                    }
                }
                
                // è¿æ¥ SSE
                const errorEventSource = new EventSource(testUrl);
                stats.totalConnections++;
                stats.activeConnections++;
                
                errorEventSource.onopen = function() {
                    addLog('errorLog', 'success', 'é”™è¯¯æµ‹è¯•è¿æ¥å·²å»ºç«‹');
                };
                
                errorEventSource.onmessage = function(event) {
                    stats.totalMessages++;
                    addLog('errorLog', 'data', 'é”™è¯¯æµ‹è¯•æ¥æ”¶æ•°æ®', JSON.parse(event.data));
                    updateStats();
                };
                
                errorEventSource.onerror = function(event) {
                    addLog('errorLog', 'error', 'é¢„æœŸçš„é”™è¯¯å‘ç”Ÿ');
                    stats.errorCount++;
                    stats.activeConnections--;
                    errorEventSource.close();
                    updateStats();
                };
                
                // 5ç§’åè‡ªåŠ¨å…³é—­
                setTimeout(() => {
                    if (errorEventSource.readyState !== EventSource.CLOSED) {
                        errorEventSource.close();
                        stats.activeConnections--;
                        addLog('errorLog', 'info', 'é”™è¯¯æµ‹è¯•è¿æ¥å·²å…³é—­');
                        updateStats();
                    }
                }, 5000);
                
            } catch (error) {
                addLog('errorLog', 'error', 'é”™è¯¯æµ‹è¯•å¤±è´¥: ' + error.message);
                stats.errorCount++;
                updateStats();
            }
        }

        // æ›´æ–°è¿æ¥çŠ¶æ€
        function updateConnectionStatus(prefix, status, text) {
            const indicator = document.getElementById(prefix + 'Status');
            const textElement = document.getElementById(prefix + 'StatusText');
            
            indicator.className = `status-indicator status-${status}`;
            if (textElement) {
                textElement.textContent = text;
            }
        }

        // æ¸…ç©ºæ—¥å¿—å‡½æ•°
        function clearBasicLog() {
            document.getElementById('basicLog').innerHTML = '';
        }
        
        function clearConcurrentLog() {
            document.getElementById('concurrentLog').innerHTML = '';
        }
        
        function clearLongRunningLog() {
            document.getElementById('longRunningLog').innerHTML = '';
        }
        
        function clearErrorLog() {
            document.getElementById('errorLog').innerHTML = '';
        }

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            stats.startTime = Date.now();
            
            // å®šæœŸæ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            setInterval(updateStats, 1000);
            
            // è®¾ç½®é»˜è®¤å‚æ•°
            document.getElementById('basicArguments').value = '{"args": [1]}';
            
            addLog('basicLog', 'info', 'SSE æµ‹è¯•å®¢æˆ·ç«¯å·²å°±ç»ª');
            addLog('concurrentLog', 'info', 'å¹¶å‘æµ‹è¯•æ¨¡å—å·²å°±ç»ª');
            addLog('longRunningLog', 'info', 'é•¿æ—¶é—´æµ‹è¯•æ¨¡å—å·²å°±ç»ª');
            addLog('errorLog', 'info', 'é”™è¯¯æµ‹è¯•æ¨¡å—å·²å°±ç»ª');
        });

        // é¡µé¢å…³é—­æ—¶æ¸…ç†è¿æ¥
        window.addEventListener('beforeunload', function() {
            if (basicEventSource) basicEventSource.close();
            if (longRunningEventSource) longRunningEventSource.close();
            concurrentEventSources.forEach(es => es.close());
        });
    </script>
</body>
</html>


